import{_ as s,o as a,c as n,Q as e}from"./chunks/framework.7b60570d.js";const o="/portal/images/webpack/loader-pitch.png",b=JSON.parse('{"title":"Webpack 知识汇总","description":"","frontmatter":{},"headers":[],"relativePath":"fe/engineering/webpack.md","lastUpdated":1704382926000}'),l={name:"fe/engineering/webpack.md"},p=e('<h1 id="webpack-知识汇总" tabindex="-1">Webpack 知识汇总 <a class="header-anchor" href="#webpack-知识汇总" aria-label="Permalink to &quot;Webpack 知识汇总&quot;">​</a></h1><h2 id="一、工作流程" tabindex="-1">一、工作流程 <a class="header-anchor" href="#一、工作流程" aria-label="Permalink to &quot;一、工作流程&quot;">​</a></h2><h3 id="_1、基本构建流程" tabindex="-1">1、基本构建流程 <a class="header-anchor" href="#_1、基本构建流程" aria-label="Permalink to &quot;1、基本构建流程&quot;">​</a></h3><h4 id="_1-1、初始化参数" tabindex="-1">1.1、初始化参数 <a class="header-anchor" href="#_1-1、初始化参数" aria-label="Permalink to &quot;1.1、初始化参数&quot;">​</a></h4><p>从配置文件和 <code>Shell</code> 命令中读取和合并参数，得多最终的配置 <code>config</code></p><h4 id="_1-2、开始编译" tabindex="-1">1.2、开始编译 <a class="header-anchor" href="#_1-2、开始编译" aria-label="Permalink to &quot;1.2、开始编译&quot;">​</a></h4><p>调用 <code>webpack</code> 函数接受 <code>config</code> 配置信息，并初始化 <code>complier</code> 对象, 加载配置的所有 <code>plugin</code>, 执行<code>complier.run</code> 方法进入模版编译阶段, 根据配置项 <code>entry</code> 确定入口文件</p><h4 id="_1-3、编译模块" tabindex="-1">1.3、编译模块 <a class="header-anchor" href="#_1-3、编译模块" aria-label="Permalink to &quot;1.3、编译模块&quot;">​</a></h4><p>每一次新的编译都会实例化一个 <code>compilation</code> 对象，记录本次编译的基本信息。编译从入口文件出发：</p><ul><li><p>调用合适的 <code>loader</code> 对模块进行处理，转换成标准的<code>js</code>模块</p></li><li><p>调用第三方插件<code>acorn</code>对标准<code>js</code>模块进行分析，收集模块依赖项，同时会递归每个依赖项，收集依赖项的依赖信息，如此往复，最终会得到一个依赖树</p></li></ul><h4 id="_1-4、完成编译模块" tabindex="-1">1.4、完成编译模块 <a class="header-anchor" href="#_1-4、完成编译模块" aria-label="Permalink to &quot;1.4、完成编译模块&quot;">​</a></h4><p>根据入口和模块的依赖关系，将多个模块组装成一个个 <code>chunk</code>, 再将每个 <code>chunk</code> 转化成一个单独的文件加入到<strong>输出列表</strong>（ ps: <em>这步是修改输出文件内容的最后机会</em> ）</p><h4 id="_1-5、输出完成" tabindex="-1">1.5、输出完成 <a class="header-anchor" href="#_1-5、输出完成" aria-label="Permalink to &quot;1.5、输出完成&quot;">​</a></h4><p>确定好输出内容后，按照配置确定输出的文件名和路径，把文件内容写入到文件系统中</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在上述整个过程中，<code>webpack</code> 会在特定的时间<strong>广播</strong>特定的事件( <code>hook</code>钩子函数 )，插件在监听到感兴趣的事件后会执行回调函数，利用 <code>webpack</code> 提供的 <code>api</code> 修改最后的输出结果</p></div><h3 id="_2、核心概念" tabindex="-1">2、核心概念 <a class="header-anchor" href="#_2、核心概念" aria-label="Permalink to &quot;2、核心概念&quot;">​</a></h3><h4 id="_2-1、compiler" tabindex="-1">2.1、compiler <a class="header-anchor" href="#_2-1、compiler" aria-label="Permalink to &quot;2.1、compiler&quot;">​</a></h4><p>编译器对象，其实例包含了完整的 <code>webpack</code> 配置，且全局只有一个 <code>compiler</code> 实例，相当于 <code>webpack</code> 的骨架或神经中枢，通过该对象可访问 <code>webpack</code> 内部环境</p><h4 id="_2-2、compilation" tabindex="-1">2.2、compilation <a class="header-anchor" href="#_2-2、compilation" aria-label="Permalink to &quot;2.2、compilation&quot;">​</a></h4><p><code>compilation</code> 对象代表了一次资源版本构建。当运行 <code>webpack</code> 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 <code>compilation</code>，从而生成一组新的编译资源</p><h2 id="二、什么是-loader" tabindex="-1">二、什么是 loader <a class="header-anchor" href="#二、什么是-loader" aria-label="Permalink to &quot;二、什么是 loader&quot;">​</a></h2><p><code>loader</code> 直译加载器。<code>Webpack</code> 将一切文件视为模块，但 <code>Webpack</code> 原生只支持解析 <code>JS</code>、<code>JSON</code> 文件，如果想打包其它文件，就需要使用的 <code>loader</code>, 所以说：</p><p><strong><code>loader</code> 的作用是让 <code>webpack</code> 拥有了加载和解析非 <code>JS</code>、<code>JSON</code> 文件的能力</strong></p><h3 id="_3、开发中常见的-loader" tabindex="-1">3、开发中常见的 loader <a class="header-anchor" href="#_3、开发中常见的-loader" aria-label="Permalink to &quot;3、开发中常见的 loader&quot;">​</a></h3><p><strong>处理 <code>less/css</code></strong></p><table><thead><tr><th>loader</th><th>作用</th></tr></thead><tbody><tr><td><strong>less-loader</strong></td><td>把 <code>less</code> 文件编译成 <code>CSS</code></td></tr><tr><td><strong>postcss-loader</strong></td><td>使用<code>PostCSS</code> 处理<code>CSS</code>，可配合<code>autoprefixer</code>加前缀</td></tr><tr><td><strong>css-loader</strong></td><td>处理 <code>url、@import</code> 等语法</td></tr><tr><td><strong>style-loader</strong></td><td>（<code>dev</code>）将<code>CSS</code>代码通过 <code>style</code> 标签以内联方式插入</td></tr><tr><td><strong>MiniCssExtractPlugin.loader</strong></td><td>（<code>prod</code>）将<code>CSS</code>代码抽离成单独的 <code>CSS</code> 文件，有<strong>缓存</strong>作用</td></tr></tbody></table><p><strong>处理图片、字体</strong></p><table><thead><tr><th>loader</th><th>作用</th></tr></thead><tbody><tr><td><strong>file-loader</strong></td><td>把文件拷贝到一个文件夹，在代码中通过相对 <code>URL</code> 去引用文件内容，通过设置哈希来获得缓存</td></tr><tr><td><strong>url-loader</strong></td><td>设置一个<strong>阀值</strong>，当文件大小小于阀值，以 <code>base64</code> 的方式把文件内容注入到代码中（减少<code>HTTP</code>请求）; 大于阀值，使用 <code>file-loader</code> 处理</td></tr></tbody></table><p><strong>处理 JS</strong></p><table><thead><tr><th>loader</th><th>作用</th></tr></thead><tbody><tr><td><strong>eslint-loader</strong></td><td>通过 <code>eslint</code> 检查 <code>JS</code> 代码</td></tr><tr><td><strong>babel-loader</strong></td><td>将 <code>ES6+</code> 代码转化成 <code>ES5</code> 代码</td></tr></tbody></table><p><strong>处理 Vue</strong></p><table><thead><tr><th>loader</th><th>作用</th></tr></thead><tbody><tr><td><strong>vue-loader</strong></td><td>允许使用<strong>单文件组件</strong>(SFCs)的格式撰写 vue 组件</td></tr></tbody></table><p><strong>优化性能</strong></p><table><thead><tr><th>loader</th><th>作用</th></tr></thead><tbody><tr><td><strong>cache-loader</strong></td><td>将 <code>loader</code> 的结果缓存到磁盘中，有效减少非首次构建时间</td></tr><tr><td><strong>thread-loader</strong></td><td><code>thread-loader</code> 之后的 <code>loader</code> 就会在一个单独的 <code>worker</code> 池中运行</td></tr></tbody></table><h3 id="_4、loader-的工作原理" tabindex="-1">4、loader 的工作原理 <a class="header-anchor" href="#_4、loader-的工作原理" aria-label="Permalink to &quot;4、loader 的工作原理&quot;">​</a></h3><ul><li><p><code>loader</code> 只是一个导出为<strong>函数</strong>的 JS 模块，<code>loader runner</code>会调用该函数，该函数接受文件资源或上一个 loader 的处理结果作为入参，多个 <code>loader</code> 可组成 <code>loader chain</code></p></li><li><p><code>complier</code> 只需要最后一个 <code>loader</code> 的处理结果，结果应该是 <code>String</code> 或 <code>Buffer</code></p></li></ul><h4 id="_4-1、loader-runner" tabindex="-1">4.1、<code>loader-runner</code> <a class="header-anchor" href="#_4-1、loader-runner" aria-label="Permalink to &quot;4.1、`loader-runner`&quot;">​</a></h4><p>一个执行 <code>loader chain</code> 的模块</p><h4 id="_4-2、loader类型" tabindex="-1">4.2、<code>loader</code>类型 <a class="header-anchor" href="#_4-2、loader类型" aria-label="Permalink to &quot;4.2、`loader`类型&quot;">​</a></h4><p><code>post</code>(后置) + <code>inline</code>(内联) + <code>normal</code>(普通) + <code>pre</code>(前置)</p><p>可通过 <code>enforce</code> 设置</p><h4 id="_4-3、特殊配置" tabindex="-1">4.3、特殊配置 <a class="header-anchor" href="#_4-3、特殊配置" aria-label="Permalink to &quot;4.3、特殊配置&quot;">​</a></h4><p>可通过设置以下特殊字符来忽略某种类型的 loader</p><table><thead><tr><th>符合</th><th>含义</th></tr></thead><tbody><tr><td><strong><code>-!</code></strong></td><td><code>noPreAutoLoaders</code>, 不要前置和普通 loader</td></tr><tr><td><strong><code>!</code></strong></td><td><code>noAutoLoaders</code>, 不要普通 loader</td></tr><tr><td><strong><code>!!</code></strong></td><td><code>noPrePostAutoLoaders</code>, 只要内联 loader</td></tr></tbody></table><h4 id="_4-4、pitch" tabindex="-1">4.4、pitch <a class="header-anchor" href="#_4-4、pitch" aria-label="Permalink to &quot;4.4、pitch&quot;">​</a></h4><p>一个 <code>loader</code> 在内部是由 <code>loader</code> 和 <code>loader.pitch</code> 组成。</p><p>比如 <code>a!b!c!module</code>, loader 的调用顺序是 <code>c -&gt; b -&gt; a</code>, 但在处理<code>module</code>之前，其实执行了 <code>a(pitch) -&gt; b(pitch) -&gt; c(pitch)</code>, 如果其中任何一个 <code>pitching loader</code> 有返回值就相当于在它及右侧的 <code>loader</code> 都执行完毕了。</p><p>例如：<code>b(pitch)</code> 执行又返回值，接下来<code>c</code>不会被执行，只有 <code>a</code> 会被执行，并且 <code>a loader</code> 接受的参数是 <code>b(pitch)</code> 的返回值</p><p><img src="'+o+`" alt="loader pitch"></p><h3 id="_5、如何手写-loader" tabindex="-1">5、如何手写 loader ？ <a class="header-anchor" href="#_5、如何手写-loader" aria-label="Permalink to &quot;5、如何手写 loader ？&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">手写 <code>loader</code> 的思路</p><ul><li><p><code>loader</code> 支持链式调用，所以需要严格遵循 “单一职责”， 每个 <code>loader</code> 只处理自己负责的事情</p></li><li><p><code>Webpack</code> 传给 <code>loader</code> 的原内容都是 <code>UTF-8</code> 格式编码的字符串，当某些场景下 <code>loader</code> 处理二进制文件时，需要通过 <code>exports.raw = true</code> 告诉 <code>Webpack</code> 该 <code>loader</code> 是否需要二进制数据</p></li><li><p>尽可能异步 <code>loader</code></p></li><li><p><code>loader</code> 是无状态的，<code>loader</code> 内部不应该保留状态</p></li></ul></div><h2 id="三、什么是-plugin" tabindex="-1">三、什么是 plugin <a class="header-anchor" href="#三、什么是-plugin" aria-label="Permalink to &quot;三、什么是 plugin&quot;">​</a></h2><p><code>plugin</code> 直译 <code>插件</code>。用来扩展 <code>webpack</code> 的功能，让 <code>webpack</code> 更加灵活，在 <code>webpack</code> 生命周期中会<strong>广播</strong>出许多事件，<code>plugin</code> 可以监听这些事件，在合适的时机利用 <code>webpack</code> 提供的 <code>api</code> 修改打包结果</p><h3 id="_6、开发中常见的-plugin" tabindex="-1">6、开发中常见的 plugin <a class="header-anchor" href="#_6、开发中常见的-plugin" aria-label="Permalink to &quot;6、开发中常见的 plugin&quot;">​</a></h3><table><thead><tr><th>plugin</th><th>作用</th></tr></thead><tbody><tr><td><strong>ModuleScopePlugin</strong></td><td>限制所引入的文件范围</td></tr><tr><td><strong>MiniCssExtractPlugin</strong></td><td>将<code>CSS</code>抽离成单独的文件</td></tr><tr><td><strong>OptimizeCssAssetsPlugin</strong></td><td>对<code>CSS</code>代码进行压缩</td></tr><tr><td><strong>SpeedMeasurePlugin</strong></td><td>统计各个 <code>loader</code> 和插件所花费的时间</td></tr><tr><td><strong>TerserWebpackPlugin</strong></td><td><code>webpack</code> 默认使用 <code>terser</code> 来压缩 <code>JS</code>，可开启多进程</td></tr><tr><td><strong>CleanWebpackPlugin</strong></td><td>清除文件夹中内容</td></tr><tr><td><strong>webpack.DefinePlugin</strong></td><td>定义环境变量，保证在<code>JS</code>中可获取</td></tr><tr><td><strong>webpack.HotModuleReplacementPlugin</strong></td><td>模块热更新插件</td></tr><tr><td><strong>webpack-bundle-analyzer</strong></td><td>借助 <code>webpack-bundle-analyzer</code> 可查看打包后每个包的体积较大</td></tr></tbody></table><h3 id="_7、如何手写-plugin" tabindex="-1">7、如何手写 plugin <a class="header-anchor" href="#_7、如何手写-plugin" aria-label="Permalink to &quot;7、如何手写 plugin&quot;">​</a></h3><p><code>webpack plugin</code> 由以下部分组成</p><ul><li><p><code>plugin</code> 通常是一个 <code>JS</code> 命名的函数，在其原型上存在 <code>apply</code> 方法</p></li><li><p><code>apply</code> 方法接收 <code>complier</code> 对象作为参数，在方法中注册 <code>webpack</code> 自身的事件钩子, 并添加回调方法</p></li><li><p>在回调方法中，可处理 <code>webpack</code> 的打包数据，处理结束后通过 <code>webpack</code> 自身的回调返回</p></li></ul><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">DonePlugin</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">options</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">options</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">options</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">apply</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">compiler</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 注册监听事件</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">compiler</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hooks</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">done</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tapAsync</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">DonePlugin</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">stats</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;font-style:italic;">callback</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Hello </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">options</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">callback</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> DonePlugin</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>当项目越来越大，<code>webpack</code> 的瓶颈就体现在两个方面，分别是：</p><ul><li>构建过程耗时太长</li><li>打包产物体积太大</li></ul><p>所以，webpack 的性能优化需要从这两个痛点下手</p><h2 id="四、webpack-优化策略" tabindex="-1">四、Webpack 优化策略 <a class="header-anchor" href="#四、webpack-优化策略" aria-label="Permalink to &quot;四、Webpack 优化策略&quot;">​</a></h2><h3 id="_8、构建过程提速" tabindex="-1">8、构建过程提速 <a class="header-anchor" href="#_8、构建过程提速" aria-label="Permalink to &quot;8、构建过程提速&quot;">​</a></h3><h4 id="_8-1、耗时分析" tabindex="-1">8.1、耗时分析 <a class="header-anchor" href="#_8-1、耗时分析" aria-label="Permalink to &quot;8.1、耗时分析&quot;">​</a></h4><p>使用<code>SpeedMeasureWebpackPlugin</code> 插件可统计打包构建过程中每个 <code>loader</code>、<code>plugin</code> 所消耗的时间</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> SpeedMeasureWebpackPlugin </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">speed-measure-webpack-plugin</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> smw </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">SpeedMeasureWebpackPlugin</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> smw</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">wrap</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// config 配置</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_8-2、缩小范围" tabindex="-1">8.2、缩小范围 <a class="header-anchor" href="#_8-2、缩小范围" aria-label="Permalink to &quot;8.2、缩小范围&quot;">​</a></h4><ul><li><p><strong>extensions</strong>: 指定 <code>extensions</code> 后导入文件不需要添加文件扩展名，<code>webpack</code> 会依次尝试添加扩展名进行尝试</p></li><li><p><strong>alias</strong>: 配置别名，可加快 <code>webpack</code> 查找模块速度</p></li><li><p><strong>exclude / include</strong>: 确保转译尽可能少的文件, <code>exclude</code>指定要排除的文件，<code>include</code> 指定要包含的文件，<code>exclude</code> 的优先级高于 <code>include</code></p></li><li><p><strong>external</strong>: 当引入一个库，但又不想让 <code>webpack</code> 打包，并且不影响正常导入使用，可在 <code>external</code> 中进行配置</p></li><li><p><strong>noParse</strong>: <code>module.noParse </code> 字段用于配置哪些模块文件的内容不需要进行解析，过滤的文件中不能使用 <code>import</code>, <code>require</code> 等语法</p></li></ul><h4 id="_8-3、利用缓存" tabindex="-1">8.3、利用缓存 <a class="header-anchor" href="#_8-3、利用缓存" aria-label="Permalink to &quot;8.3、利用缓存&quot;">​</a></h4><p>利用缓存可以提升重复构建的速度</p><ul><li><p><strong>babel-loader</strong>: <code>Babel</code> 在转译 JS 文件时性能消耗高，可将 <code>babel-loader</code> 执行的结果进行缓存，当重新打包时会尝试读取缓存。</p><p>默认存放位置是 <code>node_modules/.cache/babel-loader</code></p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">loader</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">babel-loader</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">options</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">cacheDirectory</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><p><strong>cache-loader</strong>: 在一些性能开销大的 <code>loader</code> 之前添加 <code>cache-loader</code> ，可以将<code>loader</code>处理结果缓存到磁盘中</p><p>默认保存在 <code>node_modules/.cache/cache-loader</code> 目录下</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">test</span><span style="color:#89DDFF;">:</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;">\\.</span><span style="color:#C3E88D;">css</span><span style="color:#89DDFF;font-style:italic;">$</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">use</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">cache-loader</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">logger-loader</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">style-loader</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">css-loader</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">  ]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li><li><p><strong>hard-source-webpack-plugin</strong> : 为模块提供中间缓存，节约第二次构建时间。（ <code>webpack5</code>中内置 ）</p></li></ul><h4 id="_8-4、多进程处理" tabindex="-1">8.4、多进程处理 <a class="header-anchor" href="#_8-4、多进程处理" aria-label="Permalink to &quot;8.4、多进程处理&quot;">​</a></h4><ul><li><strong><code>thread-loader</code></strong>: 放在其它 <code>loader</code> 之前，后置的 <code>loader</code> 就会在一个单独的 <code>worker</code> 池中运行</li></ul><h3 id="_9、压缩打包体积" tabindex="-1">9、压缩打包体积 <a class="header-anchor" href="#_9、压缩打包体积" aria-label="Permalink to &quot;9、压缩打包体积&quot;">​</a></h3><h4 id="_9-1、体积分析" tabindex="-1">9.1、体积分析 <a class="header-anchor" href="#_9-1、体积分析" aria-label="Permalink to &quot;9.1、体积分析&quot;">​</a></h4><p>使用<code>webpack-bundle-analyzer</code> 插件可以可视化展示打包出的文件包含哪些，大小占比如何，模块包含关系，依赖项等等，有利于我们进行优化。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> BundleAnalyzerPlugin </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">webpack-bundle-analyzer</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">BundleAnalyzerPlugin</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">plugins</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">BundleAnalyzerPlugin</span><span style="color:#A6ACCD;">()]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_9-2、代码压缩" tabindex="-1">9.2、代码压缩 <a class="header-anchor" href="#_9-2、代码压缩" aria-label="Permalink to &quot;9.2、代码压缩&quot;">​</a></h4><ul><li>JS 文件：<code>TenserWebpackPlugin</code> 插件</li><li>CSS 文件：<code>OptimizeCssAssetsWebpackPlugin</code></li><li>Images：<code>image-webpack-loader</code> 对图片进行压缩和优化</li></ul><h4 id="_9-3、删除无用代码" tabindex="-1">9.3、删除无用代码 <a class="header-anchor" href="#_9-3、删除无用代码" aria-label="Permalink to &quot;9.3、删除无用代码&quot;">​</a></h4><ul><li>JS: <code>TreeShaking</code>, 没有使用到方法不会打进 <code>bundle</code> 里面，利用<code>es6</code> 模块的特点</li><li>CSS: <code>PurgecssWebpackPlugin</code></li></ul><h4 id="_9-4、代码分割" tabindex="-1">9.4、代码分割 <a class="header-anchor" href="#_9-4、代码分割" aria-label="Permalink to &quot;9.4、代码分割&quot;">​</a></h4><h5 id="_9-4-1、入口点分割-entry-point" tabindex="-1">9.4.1、入口点分割：<code>Entry Point</code> <a class="header-anchor" href="#_9-4-1、入口点分割-entry-point" aria-label="Permalink to &quot;9.4.1、入口点分割：\`Entry Point\`&quot;">​</a></h5><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">entry</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">index</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./src/index.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">login</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./src/login.js</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>缺点</strong>：</p><ul><li>若两个入口 <code>chunk</code> 都引用了重复模块(<code>lodash</code>),那么重复模块会被引入到每个 <code>bundle</code> 中</li><li>不够灵活，不能对核心代码做进一步拆分</li></ul><h5 id="_9-4-2、动态导入和懒加载" tabindex="-1">9.4.2、动态导入和懒加载 <a class="header-anchor" href="#_9-4-2、动态导入和懒加载" aria-label="Permalink to &quot;9.4.2、动态导入和懒加载&quot;">​</a></h5><p><strong>按需加载</strong>：根据用户当前需要用什么功能就只加载该功能对应的代码</p><p><strong>拆分原则</strong>:</p><ul><li>按照网站功能(或路由)拆分，一类功能对应一个 <code>chunk</code></li><li>首页需要的功能模块直接加载，展示给用户</li><li>被分割出去的代码需要一个按需加载的时机</li></ul><p>都是使用 <code>import()</code> 关键字来实现的</p><h5 id="_9-4-3、提取公共代码" tabindex="-1">9.4.3、提取公共代码 <a class="header-anchor" href="#_9-4-3、提取公共代码" aria-label="Permalink to &quot;9.4.3、提取公共代码&quot;">​</a></h5><p><strong>拆分准则</strong>:</p><ul><li>各种类库，适合长期存储</li><li>页面之间的公共代码</li><li>每个页面单独生成的文件</li></ul><details class="details custom-block"><summary>splitChunks 配置参考</summary><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">splitChunks</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">chunks</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">all</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//默认作用于异步chunk，值为 all/initial/async</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">minSize</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//默认值是30kb,代码块的最小尺寸</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">minChunks</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//被多少模块共享, 在分割之前模块的被引用次数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">maxAsyncRequests</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//限制异步模块内部的并行最大请求数的，可以理解为是每个import()它里面的最大并行请求数量</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">maxInitialRequests</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//限制入口的拆分数量</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">name</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//打包后的名称，默认是chunk的名字通过分隔符（默认是～）分隔开，如vendor~</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">automaticNameDelimiter</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">~</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//默认webpack将会使用入口名和代码块的名称生成命名,比如 &#39;vendors~main.js&#39;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#FFCB6B;">cacheGroups</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//设置缓存组用来抽取满足不同规则的chunk,下面以生成common为例</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">vendors</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">chunks</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">all</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">test</span><span style="color:#89DDFF;">:</span><span style="color:#C3E88D;"> </span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">node_modules</span><span style="color:#89DDFF;">/</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//条件</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">priority</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">///优先级，一个chunk很可能满足多个缓存组，会被抽取到优先级高的缓存组中,为了能够让自定义缓存组有更高的优先级(默认0),默认缓存组的priority属性为负值.</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#FFCB6B;">commons</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">chunks</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">all</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">minSize</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//最小提取字节数</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">minChunks</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//最少被几个chunk引用</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#FFCB6B;">priority</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">20</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div></details><h4 id="_9-5、设置-cdn" tabindex="-1">9.5、设置 CDN <a class="header-anchor" href="#_9-5、设置-cdn" aria-label="Permalink to &quot;9.5、设置 CDN&quot;">​</a></h4><p><code>CDN</code> 又叫内容分发网络，通过将资源部署到全球各地，用户在访问时按照就近原则从最近的服务器上下载资源，从而加速获取资源的速度</p><p><strong>缓存设置</strong>：</p><ul><li><code>HTML</code> 文件不设置缓存，放到自己服务器上</li><li>静态 <code>JS</code>、<code>CSS</code> 文件开启 <code>CDN</code> 和缓存，并且文件名带上 <code>hash</code> 值</li><li>为了并行不加塞，把不同资源的文件部署到不同的<code>CDN</code>服务器上</li></ul>`,100),c=[p];function r(t,d,i,F,y,D){return a(),n("div",null,c)}const h=s(l,[["render",r]]);export{b as __pageData,h as default};
